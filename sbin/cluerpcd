#!/usr/bin/env perl
use v5.10; # Damn right.
use warnings;
use strict;
use feature "switch";
use Authen::Krb5::Simple;
use Authen::SASL;
use Cluenet::Common;
use Cluenet::Kerberos;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use Data::Dumper;
use File::Basename;
use IO::Handle;
use IPC::Open2;
use JSON;
use MIME::Base64;
use Sys::Syslog qw(:standard :macros);

use constant {
	SASL_SERVICE	=> "host",
	KRB5_KEYTAB	=> "/home/grawity/cluenet/etc/cluerpc.keytab",
	COMMAND_DIR	=> "/home/grawity/cluenet/cluerpc-server",
	HELPER_DIR	=> "/home/grawity/cluenet/cluerpc-server",
};

my $state = {};
my %commands;

# SASL authentication

sub authorize {
	my ($state, $authzid, $user) = @_;
	syslog(LOG_DEBUG, "authorize called: authz=$authzid user=$user");
	given ($state->{sasl}->mechanism) {
		when ("GSSAPI") {
			return krb5_kuserok($authzid, $user);
		}
		default {
			return krb5_canonuser($authzid) eq $user;
		}
	}
}

sub checkpass {
	my ($state, $user, $pass) = @_;
	syslog(LOG_DEBUG, "checkpass called: user=$user");
	my $krb = Authen::Krb5::Simple->new;
	return $krb->authenticate($user, $pass);
}

my %callbacks = (
	user => sub {
		die "user callback: ".Dumper(\@_);
	},

	checkpass => sub {
		my ($state, $user, $pass) = @_;
		if (checkpass($state, $user, $pass)) {
			$state->{user} = $user;
			return 1;
		} else {
			return 0;
		}
	},

	authorize => sub {
		my ($state, $authzid, $user) = @_;
		if (authorize($state, $authzid, $user)) {
			$state->{user} = $user;
			$state->{authzid} = $authzid;
			return 1;
		} else {
			return 0;
		}
	},

	password => sub {
		warn "getsecret ".Dumper([@_]);
	},

	canonuser => sub {
		my ($state, $type, $_a, $flags, $user) = @_;
		given ($type) {
			when ("AUTHID") {
				return krb5_canonuser($user);
			}
			default {
				return $user;
			}
		}
	},
);

## RPC commands

$commands{auth} = sub {
	my ($state, $req) = @_;
	my ($auth, $response, $challenge);

	if ($state->{authed}) {
		return {failure,
			msg => "already authenticated"};
	}

	$response = b64_decode($req->{data});

	if (defined $state->{sasl}) {
		if (defined $req->{mech}) {
			return {failure,
				msg => "cannot change mechanism during authentication"};
		}
		else {
			$challenge = $state->{sasl}->server_step($response);
		}
	}
	else {
		if (defined $req->{mech}) {
			unless (uc $req->{mech} ~~ ["GSSAPI"]) {
				return {failure,
					msg => "unsupported mechanism"};
			}
			$state->{saslsteps} = 0;
			$state->{sasl} = Authen::SASL->new(
				mechanism => $req->{mech},
				# ugly hack to pass $state (really $state->{sasl}) to callbacks
				callback => {map {$_ => [$callbacks{$_}, $state]} keys %callbacks}
				)->server_new(SASL_SERVICE, getfqdn);
			$challenge = $state->{sasl}->server_start(grep {length} $response);
		}
		else {
			return {failure,
				msg => "missing mechanism"};
		}
	}

	if (++$state->{saslsteps} >= 50) {
		syslog(LOG_ERR, "infinite SASL loop");
		return {failure,
			msg => "internal error"};
	}
	elsif ($state->{sasl}->need_step) {
		return {data => b64_encode($challenge)};
	}
	elsif ($state->{sasl}->code == 0) {
		$state->{authed} = 1;
		$state->{seal_next} = 1;
		syslog(LOG_INFO, "authenticated %s as %s", $state->{authzid}, $state->{user});
		return {success,
			user => $state->{user},
			authzid => $state->{authzid}};
	}
	else {
		$state->{eof} = 1;
		return {failure,
			error => [$state->{sasl}->error],
			msg => "authentication failed"};
	}
};

$commands{"list"} = sub {
	my @cmds = map {basename($_, ".pl")} glob(COMMAND_DIR."/*.pl");
	return {success, commands => \@cmds};
};


sub get_command {
	my $cmd = shift;
	if ($cmd =~ /^\w+$/) {
		return $commands{$cmd} //= load_command($cmd);
	} else {
		return undef;
	}
}

sub load_command {
	my $cmd = shift;
	my $file = COMMAND_DIR."/".$cmd.".pl";
	if (-f $file) {
		my ($name, $sub) = do $file;
		if ($@) {
			syslog(LOG_ERR, "sourcing $file failed: $@");
		}
		if ($sub) {
			$commands{$cmd} = $sub;
			return $sub;
		}
	} else {
		syslog(LOG_NOTICE, "file not found: $file");
		return undef;
	}
}

sub handle_request {
	my ($state, $req) = @_;
	if (!defined $req->{cmd}) {
		return {failure, msg => "missing command"};
	}

	my $sub = get_command($req->{cmd});
	if (!defined $sub) {
		return {failure, msg => "invalid command"};
	}
	
	my $reply = eval {$sub->($state, $req)};
	if ($@) {
		return {failure, msg => "$@"};
	} else {
		return $reply;
	}
}

## main loop

openlog("cluerpcd", "pid", LOG_DAEMON);
setlogmask(LOG_UPTO(LOG_NOTICE));

if (defined KRB5_KEYTAB) {
	$ENV{KRB5_KTNAME} = KRB5_KEYTAB;
}

$state = Cluenet::Rpc::Server->new;
$state->{rpchelperdir} = HELPER_DIR;

my ($req, $reply, $sub);
while (my $req = $state->rpc_recv) {
	$reply = handle_request($state, $req);
	$state->rpc_send($reply);

	if ($state->{seal_next}) {
		$state->{seal} = 1;
	}
	if ($state->{eof}) {
		exit;
	}
}
