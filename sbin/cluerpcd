#!/usr/bin/env perl
use v5.10; # Damn right.
use warnings;
use strict;
use feature "switch";
use Authen::Krb5::Simple;
use Authen::SASL;
use Cluenet::Common;
use Cluenet::Kerberos;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use Data::Dumper;
use File::Basename;
use IO::Handle;
use IPC::Open2;
use JSON;
use MIME::Base64;

use constant {
	SASL_SERVICE	=> "host",
	COMMAND_DIR	=> "/cluenet/etc/cluerpcd",
	HELPER_DIR	=> "/cluenet/lib/cluerpcd",
};

my %functions;
my $conffile;
my $config;
my $server;

# SASL authentication

sub authorize {
	my ($server, $user, $authuser) = @_;
	given ($server->{sasl}->mechanism) {
		when ("GSSAPI") {
			return krb5_kuserok($user, $authuser);
		}
		default {
			return krb5_canonuser($user) eq $authuser;
		}
	}
}

sub checkpass {
	my ($server, $user, $pass) = @_;
	my $krb = Authen::Krb5::Simple->new;
	return $krb->authenticate($user, $pass);
}

my %callbacks = (
	checkpass => sub {
		my ($server, $user, $pass) = @_;
		if (checkpass($server, $user, $pass)) {
			$server->{authuser} = $user;
			return 1;
		} else {
			return 0;
		}
	},

	authorize => sub {
		my ($server, $authzid, $authnid) = @_;
		if (authorize($server, $authzid, $authnid)) {
			$server->{user} = $authzid;
			$server->{authuser} = $authnid;
			return 1;
		} else {
			return 0;
		}
	},

	canonuser => sub {
		my ($server, $type, $_a, $flags, $user) = @_;
		if ($type eq 'AUTHID') {
			return krb5_canonuser($user);
		}
		else {
			return $user;
		}
	},
);

## RPC functions

$functions{"auth"} = sub {
	my ($state, $req) = @_;
	my ($auth, $response, $challenge);

	if ($state->{authed}) {
		return {failure,
			msg => "already authenticated"};
	}

	$response = b64_decode($req->{data});

	if (defined $state->{sasl}) {
		if (defined $req->{mech}) {
			return {failure,
				msg => "cannot change mechanism during authentication"};
		}
		else {
			$challenge = $state->{sasl}->server_step($response);
		}
	}
	else {
		if (defined $req->{mech}) {
			unless (uc $req->{mech} ~~ ["GSSAPI"]) {
				return {failure,
					msg => "unsupported mechanism"};
			}
			$state->{seal_wanted} = $req->{seal} // 1;
			$sasl = Authen::SASL->new(mechanism => $req->{mech},
					# ugly hack to pass $state (really $state->{sasl}) to callbacks
					callback => {map {$_ => [$callbacks{$_}, $state]} keys %callbacks});
			$conn = $sasl->server_new(SASL_SERVICE, getfqdn);
			$state->{sasl} = $conn;
			$state->{saslsteps} = 0;
			$challenge = $state->{sasl}->server_start(grep {length} $response);
		}
		else {
			return {failure,
				msg => "missing mechanism"};
		}
	}

	if (++$state->{saslsteps} >= 50) {
		return {failure,
			msg => "internal error: infinite loop"};
	}
	elsif ($state->{sasl}->need_step) {
		return {success,
			data => b64_encode($challenge)};
	}
	elsif ($state->{sasl}->code == 0) {
		$state->{authed} = 1;
		$state->{seal_next} = $state->{seal_wanted};
		return {success,
			user => $state->{user},
			authuser => $state->{authuser},
			seal => $state->{seal_next}};
	}
	else {
		$state->{eof} = 1;
		return {failure,
			msg => "authentication failed",
			error => [$state->{sasl}->error]};
	}
};

$functions{"list"} = sub {
	my @cmds = map {basename($_, ".pl")} glob(COMMAND_DIR."/*.pl");
	push @cmds, keys %functions;
	return {success,
		functions => [sort @cmds]};
};

sub load_func {
	my $name = shift;
	return undef unless $name =~ /^\w+$/;
	return $functions{$name} if defined $functions{$name};

	my $file = COMMAND_DIR."/".$name.".pl";
	if (-f $file) {
		my ($name, $func) = do $file;
		if ($@) {
			return undef;
		}
		else {
			return $func;
		}
	}

	return undef;
}

sub handle_request {
	my ($server, $req) = @_;

	my ($func, $args) = @$req;
	if (!defined $func) {
		return {failure, msg => "missing function"};
	}

	my $handler = load_func($func);
	if (!defined $handler) {
		return {failure, msg => "invalid function: '$func'"};
	}

	my $reply = eval {$handler->($server, $args)};
	if ($@) {
		return {failure, msg => "internal error: $@"};
	} else {
		return $reply;
	}
}

## main loop

$conffile = Cluenet::Common::CONFIG_DIR."/cluerpcd.conf";
if (-f $conffile) {
	$config = do $conffile;
	if (!defined $config) {
		exit 1;
	}
}

if (defined $config->{keytab}) {
	$ENV{KRB5_KTNAME} = $config->{keytab};
}

$server = Cluenet::Rpc::Server->new;
$server->{rpchelperdir} = HELPER_DIR;

while (my $req = $server->rpc_recv) {
	my $reply = handle_request($server, $req);
	$server->rpc_send($reply);

	if ($server->{seal_next}) {
		$server->{seal} = 1;
	}
	if ($server->{eof}) {
		exit;
	}
}
