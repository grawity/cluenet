#!/usr/bin/env perl
use v5.10; # Damn right.
use warnings;
use strict;
use feature "switch";
use Authen::Krb5::Simple;
use Authen::SASL;
use Cluenet::Common;
use Cluenet::Kerberos;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use Data::Dumper;
use File::Basename;
use IO::Handle;
use IPC::Open2;
use JSON;
use MIME::Base64;
use Sys::Syslog qw(:standard :macros);

use constant {
	SASL_SERVICE	=> "host",
	COMMAND_DIR	=> "/cluenet/etc/cluerpcd",
	HELPER_DIR	=> "/cluenet/lib/cluerpcd",
};

my $state = {};
my %commands;
my $conffile;
my $config;

# SASL authentication

sub authorize {
	my ($state, $user, $authuser) = @_;
	syslog(LOG_DEBUG, "authorize called: authz=$user authn=$authuser");
	given ($state->{sasl}->mechanism) {
		when ("GSSAPI") {
			return krb5_kuserok($user, $authuser);
		}
		default {
			return krb5_canonuser($user) eq $authuser;
		}
	}
}

sub checkpass {
	my ($state, $user, $pass) = @_;
	syslog(LOG_DEBUG, "checkpass called: user=$user");
	my $krb = Authen::Krb5::Simple->new;
	return $krb->authenticate($user, $pass);
}

my %callbacks = (
	user => sub {
		die "user callback: ".Dumper(\@_);
	},

	checkpass => sub {
		my ($state, $user, $pass) = @_;
		if (checkpass($state, $user, $pass)) {
			$state->{authuser} = $user;
			return 1;
		} else {
			return 0;
		}
	},

	authorize => sub {
		my ($state, $authzid, $authnid) = @_;
		if (authorize($state, $authzid, $authnid)) {
			$state->{user} = $authzid;
			$state->{authuser} = $authnid;
			return 1;
		} else {
			return 0;
		}
	},

	password => sub {
		warn "getsecret ".Dumper([@_]);
	},

	canonuser => sub {
		my ($state, $type, $_a, $flags, $user) = @_;
		given ($type) {
			when ("AUTHID") {
				return krb5_canonuser($user);
			}
			default {
				return $user;
			}
		}
	},
);

## RPC commands

$commands{"auth"} = sub {
	my ($state, $req) = @_;
	my ($auth, $response, $challenge);

	if ($state->{authed}) {
		return {failure,
			msg => "already authenticated"};
	}

	$response = b64_decode($req->{data});

	if (defined $state->{sasl}) {
		if (defined $req->{mech}) {
			return {failure,
				msg => "cannot change mechanism during authentication"};
		}
		else {
			$challenge = $state->{sasl}->server_step($response);
		}
	}
	else {
		if (defined $req->{mech}) {
			unless (uc $req->{mech} ~~ ["GSSAPI"]) {
				return {failure,
					msg => "unsupported mechanism"};
			}
			$state->{saslsteps} = 0;
			$state->{sasl} = Authen::SASL->new(
				mechanism => $req->{mech},
				# ugly hack to pass $state (really $state->{sasl}) to callbacks
				callback => {map {$_ => [$callbacks{$_}, $state]} keys %callbacks}
				)->server_new(SASL_SERVICE, getfqdn);
			$challenge = $state->{sasl}->server_start(grep {length} $response);
		}
		else {
			return {failure,
				msg => "missing mechanism"};
		}
	}

	if (++$state->{saslsteps} >= 50) {
		syslog(LOG_ERR, "infinite SASL loop");
		return {failure,
			msg => "internal error"};
	}
	elsif ($state->{sasl}->need_step) {
		return {data => b64_encode($challenge)};
	}
	elsif ($state->{sasl}->code == 0) {
		$state->{authed} = 1;
		$state->{seal_next} = 1;
		syslog(LOG_INFO, "authenticated %s as %s", $state->{authuser}, $state->{user});
		return {success,
			user => $state->{user},
			authuser => $state->{authuser}};
	}
	else {
		$state->{eof} = 1;
		return {failure,
			msg => "authentication failed",
			error => [$state->{sasl}->error]};
	}
};

$commands{"list"} = sub {
	my @cmds = map {basename($_, ".pl")} glob(COMMAND_DIR."/*.pl");
	return {success, commands => \@cmds};
};


sub get_command {
	my $name = shift;
	return undef unless $name =~ /^\w+$/;
	return $commands{$name} if defined $commands{$name};

	my $file = COMMAND_DIR."/".$name.".pl";
	if (-f $file) {
		my ($name, $func) = do $file;
		if ($@) {
			syslog(LOG_ERR, "sourcing $file failed: $@");
			return undef;
		}
		else {
			# TODO: is this actually necessary?
			@commands{$name} = $func;
			return $func;
		}
	}

	syslog(LOG_NOTICE, "file not found: $file");
	return undef;
}

sub handle_request {
	my ($state, $req) = @_;
	if (!defined $req->{cmd}) {
		return {failure, msg => "missing command name"};
	}

	my $cmd = get_command($req->{cmd});
	if (!defined $cmd) {
		return {failure, msg => "invalid command"};
	}

	my $reply = eval { $cmd->($state, $req) };
	if ($@) {
		return {failure, msg => "$@"};
	} else {
		return $reply;
	}
}

## main loop

openlog("cluerpcd", "pid", LOG_DAEMON);
setlogmask(LOG_UPTO(LOG_NOTICE));

$conffile = Cluenet::Common::CONFIG_DIR."/cluerpcd.conf";
if (-f $conffile) {
	$config = do $conffile;
	if (!defined $config) {
		syslog(LOG_ERR, "failed loading config file: $@");
		exit 1;
	}
}

if (defined $config->{keytab}) {
	$ENV{KRB5_KTNAME} = $config->{keytab};
}

$state = Cluenet::Rpc::Server->new;
$state->{rpchelperdir} = HELPER_DIR;

my ($req, $reply, $sub);
while (my $req = $state->rpc_recv) {
	$reply = handle_request($state, $req);
	$state->rpc_send($reply);

	if ($state->{seal_next}) {
		$state->{seal} = 1;
	}
	if ($state->{eof}) {
		exit;
	}
}
