#!/usr/bin/env perl
use warnings;
use strict;
use feature "switch";
use Cluenet::Common;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use File::stat;
use IO::Handle;
use MIME::Base64;

use constant {
	BASEDIR		=> Cluenet::Common::CONFIG_DIR."/keystore",
	MAXSIZE		=> 65536,
};

sub encode_name {
	my $r = b64_encode(shift);
	$r =~ s|/|!|;
	return $r;
}

sub decode_name {
	my $r = shift;
	$r =~ s|!|/|;
	$r = b64_decode($r);
	return $r;
}

sub validate_name {
	my $n = shift;
	defined($n) and length($n) and $n !~ /[\000-\037]/;
}

rpc_helper_main {
	my ($req, $user) = @_;

	unless (defined $user) {
		return {failure,
			msg => "access denied"};
	}

	umask(077);

	unless (-d BASEDIR) {
		return {failure,
			msg => "internal error: keystore directory not found"};
	}

	my $dir = BASEDIR."/ks-".encode_name($user);

	given ($req->{action}) {
		when ("list") {
			my (@list, $fh, $file, $st);
			@list = ();
			if (-d $dir) {
				opendir($fh, $dir)
					or return {failure,
						msg => "unable to open directory",
						err => "$!"};
				while (defined($file = readdir($fh))) {
					if ($file eq '.' || $file eq '..') {
						next;
					} else {
						$st = stat($dir."/".$file);
						push @list, {
							name => decode_name($file),
							size => $st->size,
							time => $st->mtime,
						};
					}
				}
			}
			return {success,
				items => [sort @list]};
		}					
		when ("get") {
			unless (defined $req->{name}) {
				return {failure,
					msg => "missing parameter"};
			}
			my $file = $dir."/".encode_name($req->{name});
			if (!-f $file) {
				return {failure,
					msg => "no such entry"};
			}
			my ($buf, $len, $clen, $fh);
			open($fh, "<", $file)
				or return {failure,
					msg => "unable to open file",
					err => "$!"};
			while ($clen = $fh->read($buf, 16384, $len)) {
				if (defined $clen) {
					$len += $clen;
				} else {
					return {failure,
						msg => "read error",
						err => "$!"};
				}
			}
			$fh->close;

			return {success,
				len => $len,
				data => $buf};
		}
		when ("put") {
			if (grep {!defined} @{$req}{"name", "data"}) {
				return {failure,
					msg => "missing parameter"};
			}
			unless (validate_name($req->{name})) {
				return {failure,
					msg => "invalid name"};
			}
			my $file = $dir."/".encode_name($req->{name});
			my $overwrite = $req->{overwrite} // 0;
			if (-f $file && !$overwrite) {
				return {failure,
					msg => "entry exists"};
			}
			if (length $req->{data} > MAXSIZE) {
				return {failure,
					msg => "data too long"};
			}
			unless (-d $dir || mkdir($dir, 0700)) {
				return {failure,
					msg => "unable to create directory",
					err => "$!"};
			}
			
			my $fh;
			open($fh, ">", $file)
				or return {failure,
					msg => "unable to open file",
					err => "$!"};
			$fh->print($req->{data});
			$fh->close;
			return {success};
		}
		when ("rename") {
			if (grep {!defined} @{$req}{"name", "to"}) {
				return {failure,
					msg => "missing parameter"};
			}
			unless (validate_name($req->{to})) {
				return {failure,
					msg => "invalid name"};
			}
			my $file = $dir."/".encode_name($req->{name});
			if (!-f $file) {
				return {failure,
					msg => "no such entry"};
			}
			my $to = $dir."/".encode_name($req->{to});
			if (-f $to) {
				return {failure,
					msg => "entry exists"};
			}
			if (rename($file, $to)) {
				return {success};
			} else {
				return {failure,
					msg => "unable to rename file",
					err => "$!"};
			}

		}
		when ("delete") {
			unless (defined $req->{name}) {
				return {failure,
					msg => "missing parameter"};
			}
			my $file = $dir."/".encode_name($req->{name});
			if (!-f $file) {
				return {failure,
					msg => "no such entry"};
			}
			if (unlink $file) {
				return {success};
			} else {
				return {failure,
					msg => "unable to remove file",
					err => "$!"};
			}
		}
	}
};
