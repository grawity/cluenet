#!/usr/bin/env perl
use warnings;
use strict;
use feature "switch";
use Cluenet::Common;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use DBI;

use constant {
	DB_HOST		=> "DBI:mysql:host=localhost;database=grawity_cluedns",
	DB_USER		=> "cluedns",
	DB_PASSWD_FILE	=> "/cluenet/etc/cluerpcd/creds/mysql-dns",
};

sub DB_PASSWD { read_line(DB_PASSWD_FILE) }

sub in_zone {
	my $zone = lc shift; $zone =~ s/\.$//;
	my $fqdn = lc shift; $fqdn =~ s/\.$//;
	return ($zone eq $fqdn) || (".$zone" eq substr($fqdn, -length(".$zone")));
}

sub is_allowed {
	my ($user, $zone, $fqdn) = @_;
	return 0 unless in_zone($zone, $fqdn);
	# TODO: $user has access to $zone
	return 1;
}

sub trigger_reload {
	my ($zone) = @_;
	# TODO: implement
	1;
}

sub update_db {
	my ($dbh, $req, $user) = @_;

	given ($req->{action}) {
		when ("add") {
			unless ($req->{zone} and $req->{records}) {
				return {failure,
					msg => "missing parameter"};
			}

			my $zone = lc $req->{zone};
			my @records = @{$req->{records}};
			my $rows = 0;
			my $sth = $dbh->prepare(q[
					INSERT INTO `records` (`zone`, `fqdn`, `rrtype`, `data`, `ttl`)
					VALUES (?, ?, ?, ?, ?)
				]);
			$sth->bind_param(1, $zone);
			for my $rec (@records) {
				return {failure,
					msg => "missing attribute"}
					unless $rec->{fqdn} && length($rec->{type}) && length($rec->{data});

				return {failure,
					msg => "access denied"}
					unless is_allowed($user, $zone, $rec->{fqdn});

				$sth->bind_param(2, $rec->{fqdn});
				$sth->bind_param(3, uc $rec->{type});
				$sth->bind_param(4, $rec->{data});
				$sth->bind_param(5, $rec->{ttl} // 7200);
				$rows += $sth->execute;
			}
			$dbh->commit;
			trigger_reload($zone);
			return {success,
				count => $rows};
		}

		when ("delete") {
			unless ($req->{zone} and $req->{records}) {
				return {failure,
					msg => "missing parameter"};
			}

			my $zone = lc $req->{zone};
			my @records = @{$req->{records}};
			my %match;
			my $rows = 0;
			for my $rec (@records) {
				return {failure,
					msg => "missing attribute"}
					unless $rec->{fqdn};

				return {failure,
					msg => "access denied"}
					unless is_allowed($user, $zone, $rec->{fqdn});

				$match{zone} = $zone;
				$match{fqdn} = $rec->{fqdn};
				if (defined $rec->{type}) {
					$match{rrtype} = $rec->{type};
					if (defined $rec->{data}) {
						$match{data} = $rec->{data};
					}
				} else {
					return {failure,
						msg => "missing attribute: 'data' requires 'type'"};
				}
				my $sth = q[DELETE FROM `records` WHERE ].join(" AND ",
					map {$_." = ".$dbh->quote($match{$_})} keys %match);
				$rows += $dbh->do($sth);
			}
			$dbh->commit;
			trigger_reload($zone);
			return {success,
				count => $rows};
		}

		when ("delsubdomain") {
			unless ($req->{domains}) {
				return {failure,
					msg => "missing parameter"};
			}

			my @domains = @{$req->{domains}};
			my $rows = 0;
			my $sth = $dbh->prepare(q[
					DELETE FROM `records`
					WHERE fqdn = ? OR fqdn LIKE ?
				]);
			for my $domain (@domains) {
				$sth->bind_param(1, $domain);
				$sth->bind_param(2, '%.'.$domain);
				$rows += $sth->execute;
			}
			$dbh->commit;
			trigger_reload();
			return {success,
				count => $rows};
		}

		default {
			return {failure,
				msg => "invalid action"};
		}
	}
}

rpc_helper_main {
	my ($req, $user) = @_;

	my $dbh = DBI->connect(DB_HOST, DB_USER, DB_PASSWD, {
			PrintError => 0,
			RaiseError => 1,
			AutoCommit => 0,
		});
	my $reply = eval {update_db($dbh, $req, $user)};
	$dbh->disconnect;
	if ($@) { die "$@\n" } else { return $reply }
};
