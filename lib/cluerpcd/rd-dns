#!/usr/bin/env perl
use common::sense;
use Cluenet::Authz;
use Cluenet::Common;
use Cluenet::Rpc;
use Cluenet::Rpc::Server;
use DBI;
use List::MoreUtils qw(any all);

use constant {
	DB_HOST		=> "DBI:mysql:host=localhost;database=grawity_cluedns",
	DB_USER		=> "cluedns",
	DB_PASSWD_FILE	=> "/cluenet/etc/cluerpcd/creds/mysql-dns",
};

sub DB_PASSWD { read_line(DB_PASSWD_FILE) }

sub check_acl {
	my ($user, $domain) = @_;
	return 1 if $user eq 'grawity';
	return 1 if "DEBUG TESTING MODE";
	for (get_user_authorizations($user)) {
		/^dns\^(.+)$/ && dns_match($1, $domain) && return 1;
	}
	return 0;
}

sub trigger_reload {
	my ($zone) = @_;
	# TODO: implement
	1;
}

sub update_db {
	my ($dbh, $req, $user) = @_;

	my @zones = map {$_->[0]}
		@{$dbh->selectall_arrayref(q[SELECT DISTINCT zone FROM records])};

	given ($req->{action}) {
		when ("getzones") {
			return {success,
				zones => \@zones};
		}

		when ("add") {
			unless ($req->{zone} and $req->{records}) {
				return {failure,
					msg => "missing parameter"};
			}

			my $zone = $req->{zone};
			my @records = @{$req->{records}};

			for my $rr (@records) {
				return {failure,
					msg => "missing attribute"}
					unless all {length} $rr->{fqdn}, $rr->{type}, $rr->{data};
				return {failure,
					msg => "unqualified domain"}
					unless $rr->{fqdn} =~ /\.$/;
				return {failure,
					msg => "out-of-zone domain"}
					unless dns_match($zone, $rr->{fqdn});
				return {failure,
					msg => "access denied"}
					unless check_acl($user, $rr->{fqdn});
			}

			# check if data results in valid zone
			my $r = spawn_ext(["/cluenet/lib/cluerpcd/cluedns-generate-zone", "-cz", $zone], \@records);
			if (!$r->{status}) {
				return {failure,
					msg => "invalid zone data:\n".join("\n", @{$r->{output}})};
			}

			# insert data
			my $rows = 0;
			my $sth = $dbh->prepare(q[
					INSERT INTO `records` (`zone`, `fqdn`, `type`, `data`, `ttl`)
					VALUES (?, ?, ?, ?, ?)
				]);
			for my $rr (@records) {
				$rows += $sth->execute($zone, $rr->{fqdn},
					uc $rr->{type}, $rr->{data}, $rr->{ttl});
			}
			my $sth = $dbh->prepare(q[UPDATE `soa` SET serial = ? WHERE zone = ?]);
			$sth->execute(time, $zone);
			$dbh->commit;
			trigger_reload($zone);
			return {success,
				count => $rows};
		}

		when ("validate") {
			unless ($req->{zone} and $req->{records}) {
				return {failure,
					msg => "missing parameter"};
			}

			my $zone = lc $req->{zone};
			my @records = @{$req->{records}};

			for my $rr (@records) {
				return {failure,
					msg => "missing attribute"}
					unless all {length} $rr->{fqdn}, $rr->{type}, $rr->{data};
				return {failure,
					msg => "unqualified domain"}
					unless $rr->{fqdn} =~ /\.$/;
				return {failure,
					msg => "out-of-zone domain"}
					unless dns_match($zone, $rr->{fqdn});
			}

			my $r = spawn_ext(["/cluenet/lib/cluerpcd/cluedns-generate-zone", "-cz", $zone], \@records);
			my $output = join("\n", @{$r->{output}});
			if ($r->{status}) {
				return {success,
					msg => "validation status:\n$output\n"};
			} else {
				return {failure,
					msg => "invalid zone data:\n$output\n"};
			}
		}

		when ("delete") {
			unless ($req->{zone} and $req->{records}) {
				return {failure,
					msg => "missing parameter"};
			}

			my $zone = lc $req->{zone};
			my @records = @{$req->{records}};

			for my $rr (@records) {
				return {failure,
					msg => "missing attribute"}
					unless length $rr->{fqdn};
				return {failure,
					msg => "access denied"}
					unless check_acl($user, $rr->{fqdn});
			}

			my %match;
			my $rows = 0;
			for my $rr (@records) {
				$match{zone} = $zone;
				$match{fqdn} = $rr->{fqdn};
				if (defined $rr->{type}) {
					$match{type} = $rr->{type};
					if (defined $rr->{data}) {
						$match{data} = $rr->{data};
					}
				} else {
					if (defined $rr->{data}) {
						return {failure,
							msg => "missing attribute: 'data' requires 'type'"};
					}
				}
				my $sth = q[DELETE FROM `records` WHERE ]
					.join(" AND ", map {$_." = ".$dbh->quote($match{$_})} keys %match);
				$rows += $dbh->do($sth);
			}
			my $sth = $dbh->prepare(q[UPDATE `soa` SET serial = ? WHERE zone = ?]);
			$sth->execute(time, $zone);
			$dbh->commit;
			trigger_reload($zone);
			return {success,
				count => $rows};
		}

		when ("delsubdomain") {
			unless ($req->{domains}) {
				return {failure,
					msg => "missing parameter"};
			}

			my @domains = @{$req->{domains}};
			return {failure,
				msg => "access denied"}
				unless all {check_acl($user, $_)} @domains;

			my $rows = 0;
			my $sth = $dbh->prepare(q[DELETE FROM `records` WHERE fqdn = ? OR fqdn LIKE ?]);
			for my $domain (@domains) {
				$rows += $sth->execute($domain, '%.'.$domain);
			}
			my $sth = $dbh->prepare(q[UPDATE `soa` SET serial = ? WHERE zone = ?]);
			$sth->execute(time, $zone);
			$dbh->commit;
			trigger_reload();
			return {success,
				count => $rows};
		}

		default {
			return {failure,
				msg => "invalid action"};
		}
	}
}

rpc_helper_main {
	my ($req, $user) = @_;

	my $dbh = DBI->connect(DB_HOST, DB_USER, DB_PASSWD, {
			PrintError => 0,
			RaiseError => 1,
			AutoCommit => 0,
		});
	my $reply = eval {update_db($dbh, $req, $user)};
	$dbh->disconnect;
	if ($@) { die "$@\n" } else { return $reply }
};
